/* Do not edit this file. It is produced from the corresponding .m4 source */
/*
 *  Copyright (C) 2014, Northwestern University and Argonne National Laboratory
 *  See COPYRIGHT notice in top-level directory.
 */
/* $Id: varn.m4 2320 2016-02-24 13:18:32Z wkliao $ */

#if HAVE_CONFIG_H
# include "ncconfig.h"
#endif

#include <stdio.h>
#include <unistd.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#include <assert.h>

#include <mpi.h>

#include "nc.h"
#include "ncx.h"
#include "ncmpidtype.h"
#include "macro.h"

/* ncmpi_get/put_varn_<type>_<mode> API:
 *    type:   data type of I/O buffer, buf
 *    mode:   independent (<nond>) or collective (_all)
 *
 * arguments:
 *    num:    number of start and count pairs
 *    starts: an 2D array of size [num][ndims]. Each starts[i][*] indicates
 *            the starting array indices for a subarray request. ndims is
 *            the number of dimensions of the defined netCDF variable.
 *    counts: an 2D array of size [num][ndims]. Each counts[i][*] indicates
 *            the number of array elements to be accessed. This argument
 *            can be NULL, equivalent to counts with all 1s.
 *    bufcount and buftype: these 2 arguments are only available for flexible
 *            APIs, indicating the I/O buffer memory layout. When buftype is
 *            MPI_DATATYPE_NULL, bufcount is ignored and the data type of buf
 *            is considered matched the variable data type defined in the file.
 */

static int
ncmpii_getput_varn(NC               *ncp,
                   NC_var           *varp,
                   int               num,
                   MPI_Offset* const starts[],  /* [num][varp->ndims] */
                   MPI_Offset* const counts[],  /* [num][varp->ndims] */
                   void             *buf,
                   MPI_Offset        bufcount,
                   MPI_Datatype      buftype,   /* data type of the buffer */
                   int               rw_flag,
                   int               io_method);



/*----< ncmpi_put_varn() >---------------------------------------------------*/
int
ncmpi_put_varn(int                ncid,
                int                varid,
                int                num,
                MPI_Offset* const  starts[],
                MPI_Offset* const  counts[],
                const void *buf,
                MPI_Offset         bufcount,
                MPI_Datatype       buftype)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, bufcount, API_VARN,
                                 1, 1, WRITE_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              bufcount, buftype, WRITE_REQ, INDEP_IO);
}

/*----< ncmpi_put_varn_all() >---------------------------------------------------*/
int
ncmpi_put_varn_all(int                ncid,
                int                varid,
                int                num,
                MPI_Offset* const  starts[],
                MPI_Offset* const  counts[],
                const void *buf,
                MPI_Offset         bufcount,
                MPI_Datatype       buftype)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, bufcount, API_VARN,
                                 1, 1, WRITE_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              bufcount, buftype, WRITE_REQ, COLL_IO);
}

/*----< ncmpi_get_varn() >---------------------------------------------------*/
int
ncmpi_get_varn(int                ncid,
                int                varid,
                int                num,
                MPI_Offset* const  starts[],
                MPI_Offset* const  counts[],
                 void *buf,
                MPI_Offset         bufcount,
                MPI_Datatype       buftype)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, bufcount, API_VARN,
                                 1, 1, READ_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              bufcount, buftype, READ_REQ, INDEP_IO);
}

/*----< ncmpi_get_varn_all() >---------------------------------------------------*/
int
ncmpi_get_varn_all(int                ncid,
                int                varid,
                int                num,
                MPI_Offset* const  starts[],
                MPI_Offset* const  counts[],
                 void *buf,
                MPI_Offset         bufcount,
                MPI_Datatype       buftype)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, bufcount, API_VARN,
                                 1, 1, READ_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              bufcount, buftype, READ_REQ, COLL_IO);
}



/*----< ncmpi_put_varn_text() >------------------------------------------------*/
int
ncmpi_put_varn_text(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const char   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_CHAR, WRITE_REQ, INDEP_IO);
}

/*----< ncmpi_put_varn_schar() >------------------------------------------------*/
int
ncmpi_put_varn_schar(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const schar   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_SIGNED_CHAR, WRITE_REQ, INDEP_IO);
}

/*----< ncmpi_put_varn_uchar() >------------------------------------------------*/
int
ncmpi_put_varn_uchar(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const uchar   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_UNSIGNED_CHAR, WRITE_REQ, INDEP_IO);
}

/*----< ncmpi_put_varn_short() >------------------------------------------------*/
int
ncmpi_put_varn_short(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const short   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_SHORT, WRITE_REQ, INDEP_IO);
}

/*----< ncmpi_put_varn_ushort() >------------------------------------------------*/
int
ncmpi_put_varn_ushort(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const ushort   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_UNSIGNED_SHORT, WRITE_REQ, INDEP_IO);
}

/*----< ncmpi_put_varn_int() >------------------------------------------------*/
int
ncmpi_put_varn_int(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const int   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_INT, WRITE_REQ, INDEP_IO);
}

/*----< ncmpi_put_varn_uint() >------------------------------------------------*/
int
ncmpi_put_varn_uint(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const uint   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_UNSIGNED, WRITE_REQ, INDEP_IO);
}

/*----< ncmpi_put_varn_long() >------------------------------------------------*/
int
ncmpi_put_varn_long(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const long   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_LONG, WRITE_REQ, INDEP_IO);
}

/*----< ncmpi_put_varn_float() >------------------------------------------------*/
int
ncmpi_put_varn_float(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const float   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_FLOAT, WRITE_REQ, INDEP_IO);
}

/*----< ncmpi_put_varn_double() >------------------------------------------------*/
int
ncmpi_put_varn_double(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const double   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_DOUBLE, WRITE_REQ, INDEP_IO);
}

/*----< ncmpi_put_varn_longlong() >------------------------------------------------*/
int
ncmpi_put_varn_longlong(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const long long   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_LONG_LONG_INT, WRITE_REQ, INDEP_IO);
}

/*----< ncmpi_put_varn_ulonglong() >------------------------------------------------*/
int
ncmpi_put_varn_ulonglong(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const unsigned long long   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_UNSIGNED_LONG_LONG, WRITE_REQ, INDEP_IO);
}


/*----< ncmpi_put_varn_text_all() >------------------------------------------------*/
int
ncmpi_put_varn_text_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const char   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_CHAR, WRITE_REQ, COLL_IO);
}

/*----< ncmpi_put_varn_schar_all() >------------------------------------------------*/
int
ncmpi_put_varn_schar_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const schar   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_SIGNED_CHAR, WRITE_REQ, COLL_IO);
}

/*----< ncmpi_put_varn_uchar_all() >------------------------------------------------*/
int
ncmpi_put_varn_uchar_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const uchar   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_UNSIGNED_CHAR, WRITE_REQ, COLL_IO);
}

/*----< ncmpi_put_varn_short_all() >------------------------------------------------*/
int
ncmpi_put_varn_short_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const short   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_SHORT, WRITE_REQ, COLL_IO);
}

/*----< ncmpi_put_varn_ushort_all() >------------------------------------------------*/
int
ncmpi_put_varn_ushort_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const ushort   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_UNSIGNED_SHORT, WRITE_REQ, COLL_IO);
}

/*----< ncmpi_put_varn_int_all() >------------------------------------------------*/
int
ncmpi_put_varn_int_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const int   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_INT, WRITE_REQ, COLL_IO);
}

/*----< ncmpi_put_varn_uint_all() >------------------------------------------------*/
int
ncmpi_put_varn_uint_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const uint   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_UNSIGNED, WRITE_REQ, COLL_IO);
}

/*----< ncmpi_put_varn_long_all() >------------------------------------------------*/
int
ncmpi_put_varn_long_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const long   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_LONG, WRITE_REQ, COLL_IO);
}

/*----< ncmpi_put_varn_float_all() >------------------------------------------------*/
int
ncmpi_put_varn_float_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const float   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_FLOAT, WRITE_REQ, COLL_IO);
}

/*----< ncmpi_put_varn_double_all() >------------------------------------------------*/
int
ncmpi_put_varn_double_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const double   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_DOUBLE, WRITE_REQ, COLL_IO);
}

/*----< ncmpi_put_varn_longlong_all() >------------------------------------------------*/
int
ncmpi_put_varn_longlong_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const long long   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_LONG_LONG_INT, WRITE_REQ, COLL_IO);
}

/*----< ncmpi_put_varn_ulonglong_all() >------------------------------------------------*/
int
ncmpi_put_varn_ulonglong_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                   const unsigned long long   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, WRITE_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_UNSIGNED_LONG_LONG, WRITE_REQ, COLL_IO);
}


/*----< ncmpi_get_varn_text() >------------------------------------------------*/
int
ncmpi_get_varn_text(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    char   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_CHAR, READ_REQ, INDEP_IO);
}

/*----< ncmpi_get_varn_schar() >------------------------------------------------*/
int
ncmpi_get_varn_schar(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    schar   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_SIGNED_CHAR, READ_REQ, INDEP_IO);
}

/*----< ncmpi_get_varn_uchar() >------------------------------------------------*/
int
ncmpi_get_varn_uchar(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    uchar   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_UNSIGNED_CHAR, READ_REQ, INDEP_IO);
}

/*----< ncmpi_get_varn_short() >------------------------------------------------*/
int
ncmpi_get_varn_short(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    short   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_SHORT, READ_REQ, INDEP_IO);
}

/*----< ncmpi_get_varn_ushort() >------------------------------------------------*/
int
ncmpi_get_varn_ushort(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    ushort   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_UNSIGNED_SHORT, READ_REQ, INDEP_IO);
}

/*----< ncmpi_get_varn_int() >------------------------------------------------*/
int
ncmpi_get_varn_int(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    int   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_INT, READ_REQ, INDEP_IO);
}

/*----< ncmpi_get_varn_uint() >------------------------------------------------*/
int
ncmpi_get_varn_uint(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    uint   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_UNSIGNED, READ_REQ, INDEP_IO);
}

/*----< ncmpi_get_varn_long() >------------------------------------------------*/
int
ncmpi_get_varn_long(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    long   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_LONG, READ_REQ, INDEP_IO);
}

/*----< ncmpi_get_varn_float() >------------------------------------------------*/
int
ncmpi_get_varn_float(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    float   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_FLOAT, READ_REQ, INDEP_IO);
}

/*----< ncmpi_get_varn_double() >------------------------------------------------*/
int
ncmpi_get_varn_double(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    double   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_DOUBLE, READ_REQ, INDEP_IO);
}

/*----< ncmpi_get_varn_longlong() >------------------------------------------------*/
int
ncmpi_get_varn_longlong(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    long long   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_LONG_LONG_INT, READ_REQ, INDEP_IO);
}

/*----< ncmpi_get_varn_ulonglong() >------------------------------------------------*/
int
ncmpi_get_varn_ulonglong(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    unsigned long long   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, INDEP_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_UNSIGNED_LONG_LONG, READ_REQ, INDEP_IO);
}


/*----< ncmpi_get_varn_text_all() >------------------------------------------------*/
int
ncmpi_get_varn_text_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    char   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_CHAR, READ_REQ, COLL_IO);
}

/*----< ncmpi_get_varn_schar_all() >------------------------------------------------*/
int
ncmpi_get_varn_schar_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    schar   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_SIGNED_CHAR, READ_REQ, COLL_IO);
}

/*----< ncmpi_get_varn_uchar_all() >------------------------------------------------*/
int
ncmpi_get_varn_uchar_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    uchar   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_UNSIGNED_CHAR, READ_REQ, COLL_IO);
}

/*----< ncmpi_get_varn_short_all() >------------------------------------------------*/
int
ncmpi_get_varn_short_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    short   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_SHORT, READ_REQ, COLL_IO);
}

/*----< ncmpi_get_varn_ushort_all() >------------------------------------------------*/
int
ncmpi_get_varn_ushort_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    ushort   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_UNSIGNED_SHORT, READ_REQ, COLL_IO);
}

/*----< ncmpi_get_varn_int_all() >------------------------------------------------*/
int
ncmpi_get_varn_int_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    int   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_INT, READ_REQ, COLL_IO);
}

/*----< ncmpi_get_varn_uint_all() >------------------------------------------------*/
int
ncmpi_get_varn_uint_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    uint   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_UNSIGNED, READ_REQ, COLL_IO);
}

/*----< ncmpi_get_varn_long_all() >------------------------------------------------*/
int
ncmpi_get_varn_long_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    long   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_LONG, READ_REQ, COLL_IO);
}

/*----< ncmpi_get_varn_float_all() >------------------------------------------------*/
int
ncmpi_get_varn_float_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    float   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_FLOAT, READ_REQ, COLL_IO);
}

/*----< ncmpi_get_varn_double_all() >------------------------------------------------*/
int
ncmpi_get_varn_double_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    double   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_DOUBLE, READ_REQ, COLL_IO);
}

/*----< ncmpi_get_varn_longlong_all() >------------------------------------------------*/
int
ncmpi_get_varn_longlong_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    long long   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_LONG_LONG_INT, READ_REQ, COLL_IO);
}

/*----< ncmpi_get_varn_ulonglong_all() >------------------------------------------------*/
int
ncmpi_get_varn_ulonglong_all(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const  starts[],
                   MPI_Offset* const  counts[],
                    unsigned long long   *buf)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    status = ncmpii_sanity_check(ncid, varid, NULL, NULL, 0, API_VARN,
                                 1, 0, READ_REQ, COLL_IO, &ncp, &varp);
    if (status != NC_NOERR) return status;

    /* set bufcount to -1 indicating non-flexible API */
    return ncmpii_getput_varn(ncp, varp, num, starts, counts, (void*)buf,
                              -1, MPI_UNSIGNED_LONG_LONG, READ_REQ, COLL_IO);
}



/*----< ncmpii_getput_varn() >------------------------------------------------*/
static int
ncmpii_getput_varn(NC               *ncp,
                   NC_var           *varp,
                   int               num,
                   MPI_Offset* const starts[],  /* [num][varp->ndims] */
                   MPI_Offset* const counts[],  /* [num][varp->ndims] */
                   void             *buf,
                   MPI_Offset        bufcount,
                   MPI_Datatype      buftype,   /* data type of the buffer */
                   int               rw_flag,   /* WRITE_REQ or READ_REQ */
                   int               io_method) /* COLL_IO or INDEP_IO */
{
    int i, j, el_size, status=NC_NOERR, min_st, err, free_cbuf=0;
    int req_id=NC_REQ_NULL, st, isSameGroup, position;
    void *cbuf=NULL;
    char *bufp;
    MPI_Offset packsize=0, **_counts=NULL;
    MPI_Datatype ptype;

    /* check for zero-size request */
    if (num == 0 || bufcount == 0) goto err_check;

    /* it is illegal for starts to be NULL */
    if (starts == NULL) {
        DEBUG_ASSIGN_ERROR(status, NC_ENULLSTART)
        goto err_check;
    }

    if (buftype == MPI_DATATYPE_NULL) {
        /* In this case, bufcount is ignored and will be recalculated to match
         * counts[]. Note buf's data type must match the data type of
         * variable defined in the file - no data conversion will be done.
         */
        if (counts == NULL)
            bufcount = 1;
        else {
            bufcount = 0;
            for (j=0; j<num; j++) {
                MPI_Offset bufcount_j = 1;
                for (i=0; i<varp->ndims; i++) {
                    if (counts[j][i] < 0) { /* no negative counts[][] */
                        DEBUG_ASSIGN_ERROR(err, NC_ENEGATIVECNT)
                        goto err_check;
                    }
                    bufcount_j *= counts[j][i];
                }
                bufcount += bufcount_j;
            }
        }
        /* assign buftype match with the variable's data type */
        buftype = ncmpii_nc2mpitype(varp->type);
    }

    cbuf = buf;
    if (bufcount > 0) { /* flexible API is used */
        /* pack buf into cbuf, a contiguous buffer */
        int isderived, iscontig_of_ptypes;
        MPI_Offset bnelems=0;

        /* ptype (primitive MPI data type) from buftype
         * el_size is the element size of ptype
         * bnelems is the total number of ptype elements in buftype
         */
        status = ncmpii_dtype_decode(buftype, &ptype, &el_size, &bnelems,
                                     &isderived, &iscontig_of_ptypes);

        if (status != NC_NOERR) goto err_check;

        if (bufcount != (int)bufcount) {
            DEBUG_ASSIGN_ERROR(status, NC_EINTOVERFLOW)
            goto err_check;
        }

        /* check if buftype is contiguous, if not, pack to one, cbuf */
        if (! iscontig_of_ptypes && bnelems > 0) {
            position = 0;
            packsize  = bnelems*el_size;
            if (packsize != (int)packsize) {
                DEBUG_ASSIGN_ERROR(status, NC_EINTOVERFLOW)
                goto err_check;
            }
            cbuf = NCI_Malloc((size_t)packsize);
            free_cbuf = 1;
            if (rw_flag == WRITE_REQ)
                MPI_Pack(buf, (int)bufcount, buftype, cbuf, (int)packsize,
                         &position, MPI_COMM_SELF);
        }
    }
    else {
        /* this subroutine is called from a high-level API */
        status = NCMPII_ECHAR(varp->type, buftype);
        if (status != NC_NOERR) goto err_check;

        ptype = buftype;
        el_size = ncmpix_len_nctype(varp->type);
    }

    /* We allow counts == NULL and treat this the same as all 1s */
    if (counts == NULL) {
        _counts    = (MPI_Offset**) NCI_Malloc((size_t)num * sizeof(MPI_Offset*));
        _counts[0] = (MPI_Offset*)  NCI_Malloc((size_t)(num * varp->ndims *
                                                        SIZEOF_MPI_OFFSET));
        for (i=1; i<num; i++)
            _counts[i] = _counts[i-1] + varp->ndims;
        for (i=0; i<num; i++)
            for (j=0; j<varp->ndims; j++)
                _counts[i][j] = 1;
    }
    else
        _counts = (MPI_Offset**) counts;

    /* break buf into num pieces */
    isSameGroup=0;
    bufp = (char*)cbuf;
    for (i=0; i<num; i++) {
        MPI_Offset buflen;
        for (buflen=1, j=0; j<varp->ndims; j++) {
            if (_counts[i][j] < 0) { /* any negative counts[][] is illegal */
                DEBUG_ASSIGN_ERROR(status, NC_ENEGATIVECNT)
                goto err_check;
            }
            buflen *= _counts[i][j];
        }
        if (buflen == 0) continue;
        status = ncmpii_igetput_varm(ncp, varp, starts[i], _counts[i], NULL,
                                     NULL, bufp, buflen, ptype, &req_id,
                                     rw_flag, 0, isSameGroup);
        if (status != NC_NOERR) goto err_check;

        /* use isSamegroup so we end up with one nonblocking request (only the
         * first request gets a request ID back, the rest reuse the same ID.
         * This single ID represents num nonblocking requests */
        isSameGroup=1;
        bufp += buflen * el_size;
    }

err_check:
    if (_counts != NULL && _counts != counts) {
        NCI_Free(_counts[0]);
        NCI_Free(_counts);
    }

    if (ncp->safe_mode == 1 && io_method == COLL_IO) {
        int mpireturn;
        TRACE_COMM(MPI_Allreduce)(&status, &min_st, 1, MPI_INT, MPI_MIN,
                                  ncp->nciop->comm);
        if (mpireturn != MPI_SUCCESS)
            return ncmpii_handle_error(mpireturn, "MPI_Allreduce"); 

        if (min_st != NC_NOERR) {
            if (req_id != NC_REQ_NULL) /* cancel pending nonblocking request */
                ncmpii_cancel(ncp, 1, &req_id, &st);
            if (free_cbuf) NCI_Free(cbuf);
            return status;
        }
    }

    if (io_method == INDEP_IO && status != NC_NOERR) {
        if (req_id != NC_REQ_NULL) /* cancel pending nonblocking request */
            ncmpii_cancel(ncp, 1, &req_id, &st);
        if (free_cbuf) NCI_Free(cbuf);
        return status;
    }

    num = 1;
    if (status != NC_NOERR)
        /* This can only be reached for COLL_IO and safe_mode == 0.
           Set num=0 just so this process can participate the collective
           calls in wait_all */
        num = 0;

    err = ncmpii_wait(ncp, io_method, num, &req_id, &st);

    /* unpack to user buf, if buftype is noncontiguous */
    if (status == NC_NOERR && rw_flag == READ_REQ && free_cbuf) {
        position = 0;
        MPI_Unpack(cbuf, (int)packsize, &position, buf, (int)bufcount, buftype,
                   MPI_COMM_SELF);
    }

    /* return the first error, if there is one */
    if (status == NC_NOERR) status = err;
    if (status == NC_NOERR) status = st;

    if (free_cbuf) NCI_Free(cbuf);

    return status;
}
